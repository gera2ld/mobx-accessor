"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[827],{3694:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>c,toc:()=>l});var s=t(1527),a=t(7214);const r={sidebar_position:3},o="Usage",c={id:"usage",title:"Usage",description:"Now we are going to build our accessor from its components.",source:"@site/docs/usage.md",sourceDirName:".",slug:"/usage",permalink:"/mobx-accessor/docs/usage",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Get Started",permalink:"/mobx-accessor/docs/getting-started"},next:{title:"Integration with React",permalink:"/mobx-accessor/docs/integration/usage-with-react"}},i={},l=[{value:"State",id:"state",level:2},{value:"Mutations",id:"mutations",level:2},{value:"Getters",id:"getters",level:2},{value:"Actions",id:"actions",level:2},{value:"Accessor",id:"accessor",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"usage",children:"Usage"}),"\n",(0,s.jsxs)(n.p,{children:["Now we are going to build our ",(0,s.jsx)(n.code,{children:"accessor"})," from its components."]}),"\n",(0,s.jsxs)(n.p,{children:["Helpers can be imported from ",(0,s.jsx)(n.code,{children:"mobx-accessor"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import {\n  actionTree,\n  getterTree,\n  mutationTree,\n  makeAccessor,\n} from 'mobx-accessor';\n"})}),"\n",(0,s.jsx)(n.h2,{id:"state",children:"State"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"State"})," is just an object holding the data needed for the view, usually retrieved from backend. We must define it with all possible fields."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const defState = () => ({\n  value: 1,\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["All fields in ",(0,s.jsx)(n.strong,{children:"state"})," will be accessible as ",(0,s.jsx)(n.em,{children:"getters"})," from the ",(0,s.jsx)(n.code,{children:"accessor"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["In this example, the state has only one field ",(0,s.jsx)(n.code,{children:"value"})," which is an integer. The types can be inferred from the definition, so we don't have to declare it explicitly. The final accessor will have a getter:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// Automatically created\ninterface ExampleAccessor {\n  readonly value: number;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"mutations",children:"Mutations"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Mutations"})," are functions that modify the ",(0,s.jsx)(n.strong,{children:"state"})," synchronously. It is only allowed to modify data through ",(0,s.jsx)(n.strong,{children:"mutations"})," in ",(0,s.jsx)(n.code,{children:"mobx-accessor"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["We use the ",(0,s.jsx)(n.code,{children:"mutationTree"})," helper to infer the types."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const defMutations = mutationTree({ state: defState }, {\n  increase(state) {\n    state.value++;\n  },\n  addUp(state, delta: number) {\n    state.value += delta;\n  },\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"Each function can have at most 2 parameters, the first being the current state, and the second being the payload called with this mutation."}),"\n",(0,s.jsxs)(n.p,{children:["In the example above, we will add two functions to the ",(0,s.jsx)(n.code,{children:"accessor"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// Automatically created\ninterface ExampleAccessor {\n  increase(): void;\n  addUp(delta: number): void;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"getters",children:"Getters"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Getters"})," are values computed from ",(0,s.jsx)(n.strong,{children:"state"})," or other ",(0,s.jsx)(n.strong,{children:"getters"}),". Thanks to MobX, they will always be updated automatically if any of their dependencies are changed."]}),"\n",(0,s.jsxs)(n.p,{children:["We use the ",(0,s.jsx)(n.code,{children:"getterTree"})," helper to infer the types."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const defGetters = getterTree({ state: defState }, {\n  double(state) {\n    return state.value * 2;\n  },\n  doubleAgain(state, getters) {\n    const double = getters.double as number;\n    return double * 2;\n  },\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"Each function can have at most 2 parameters, the first being the current state, and the second being an object of all available getters."}),"\n",(0,s.jsx)(n.p,{children:"Note:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The type of the second parameter ",(0,s.jsx)(n.code,{children:"getters"})," cannot be inferred as it depends on the type of itself."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Getters"})," are supposed to derive values immediately, without the ability to modify the state, thus have no access to ",(0,s.jsx)(n.strong,{children:"mutations"})," or ",(0,s.jsx)(n.strong,{children:"actions"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["In the example above, we will add two getters to ",(0,s.jsx)(n.code,{children:"accessor"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// Automatically created\ninterface ExampleAccessor {\n  readonly double: number;\n  readonly doubleAgain: number;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"actions",children:"Actions"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Actions"})," are functions dealing with the logic. It can be either synchronous or asynchronous."]}),"\n",(0,s.jsxs)(n.p,{children:["We use the ",(0,s.jsx)(n.code,{children:"actionTree"})," helper to infer the types."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const defActions = actionTree({\n  state: defState,\n  getters: defGetters,\n  mutations: defMutations,\n}, {\n  async rock({ state, getters, mutations }) {\n    // await is allowed\n    await doStuff();\n    // change value through `mutations`, don't modify `state` directly\n    mutations.increase();\n    // check the latest values\n    console.log(state.value, getters.double);\n  },\n  rockPayload({ mutations }, delta: number) {\n    mutations.addUp(delta);\n    return delta;\n  },\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Each function can have at most two parameters, the first being an object of the current ",(0,s.jsx)(n.code,{children:"{ state, getters, mutations }"}),", and the second being the payload called with this action."]}),"\n",(0,s.jsx)(n.p,{children:"Note:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Actions"})," have access to the current ",(0,s.jsx)(n.strong,{children:"state"}),", ",(0,s.jsx)(n.strong,{children:"getters"})," and ",(0,s.jsx)(n.strong,{children:"mutations"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["However, ",(0,s.jsx)(n.strong,{children:"actions"})," cannot modify ",(0,s.jsx)(n.strong,{children:"state"})," directly. Modification must be done through ",(0,s.jsx)(n.strong,{children:"mutations"})," so that MobX can easily get notified of the changes."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["In the example above, we will add two functions to the ",(0,s.jsx)(n.code,{children:"accessor"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// Automatically created\ninterface ExampleAccessor {\n  rock: () => Promise<void>;\n  rockPayload: (delta: number) => number;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"accessor",children:"Accessor"}),"\n",(0,s.jsxs)(n.p,{children:["Now let's build the ",(0,s.jsx)(n.code,{children:"accessor"})," with ",(0,s.jsx)(n.code,{children:"makeAccessor"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const accessor = makeAccessor({\n  state: defState,\n  mutations: defMutations,\n  getters: defGetters,\n  actions: defActions,\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"Now we can access everything we defined earlier from the accessor:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// typeof accessor\ninterface ExampleAccessor {\n  // From State\n  readonly value: number;\n  // From Getters\n  readonly double: number;\n  readonly doubleAgain: number;\n\n  // From Mutations\n  increase(): void;\n  addUp(delta: number): void;\n  // From Actions\n  rock: () => Promise<void>;\n  rockPayload: (delta: number) => number;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Note:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Since all properties will be merged into one accessor, no duplicate names are allowed."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);